package org.usfirst.frc.team2194.robot;

import com.ctre.CANTalon;
import com.ctre.CANTalon.FeedbackDevice;
import com.ctre.CANTalon.TalonControlMode;

import edu.wpi.first.wpilibj.AnalogInput;
import edu.wpi.first.wpilibj.Compressor;
import edu.wpi.first.wpilibj.Counter;
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.DigitalOutput;
import edu.wpi.first.wpilibj.DoubleSolenoid;
//import edu.wpi.first.wpilibj.DigitalOutput;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.PIDSourceType;
import edu.wpi.first.wpilibj.PowerDistributionPanel;
import edu.wpi.first.wpilibj.Relay;
import edu.wpi.first.wpilibj.Relay.Direction;
import edu.wpi.first.wpilibj.Relay.Value;
import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.TalonSRX;
import edu.wpi.first.wpilibj.Victor;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;

/**
 * The RobotMap is a mapping from the ports sensors and actuators are wired into
 * to a variable name. This provides flexibility changing wiring, makes checking
 * the wiring easier and significantly reduces the number of magic numbers
 * floating around.
 */
public class RobotMap {
	// For example to map the left and right motors, you could define the
	// following variables to use with your drivetrain subsystem.
	// public static int leftMotor = 1;
	// public static int rightMotor = 2;

	// If you are using multiple modules, make sure to define both the port
	// number and the module. For example you with a rangefinder:
	// public static int rangefinderPort = 1;
	// public static int rangefinderModule = 1;
	public static TalonSRX driveLeftMotor1;
	public static TalonSRX driveRightMotor1;
	public static Encoder leftEncoder;
	public static Encoder rightEncoder;
	public static RobotDrive drive;
	public static PowerDistributionPanel pdp;

	public static Victor cameraLEDs;

	public static DigitalOutput lidarPowerEnable;
	public static DigitalOutput lidarMode;
	public static Counter pwmWidth;

	public static CANTalon firstFeeder;
	public static CANTalon secondFeeder;
	public static CANTalon agitator;

	public static Encoder bottomShooterEncoder;
	public static Encoder topShooterEncoder;

	public static CANTalon topShooter;
	public static CANTalon bottomShooter;

	public static DoubleSolenoid gearGrip;
	public static DoubleSolenoid gearLift;
	public static DoubleSolenoid gearPush1;
	public static DoubleSolenoid driveShifter;
	
	public static DoubleSolenoid tiltCamera;

	public static Compressor compressor;

	public static AnalogInput leftUltrasoundSensor;
	public static AnalogInput rightUltrasoundSensor;

	public static Relay greenLedsOn;

	public static DigitalInput climberTrigger;
	public static Relay spareRelay;

	public static void init() {
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
		driveLeftMotor1 = new TalonSRX(0);
		driveRightMotor1 = new TalonSRX(1);
		driveRightMotor1.setInverted(true);
		LiveWindow.addActuator("LeftSideDrive", "Left Motor 1", driveLeftMotor1);
		LiveWindow.addActuator("RightSideDrive", "Right Motor 1", driveRightMotor1);

		drive = new RobotDrive(driveLeftMotor1, driveRightMotor1);
		drive.setSafetyEnabled(false);

		pdp = new PowerDistributionPanel(1);

		cameraLEDs = new Victor(3);

		leftEncoder = new Encoder(2, 3);
		leftEncoder.setPIDSourceType(PIDSourceType.kDisplacement);
		leftEncoder.setSamplesToAverage(10);
		leftEncoder.setReverseDirection(true);
		leftEncoder.setMaxPeriod(.5);

		rightEncoder = new Encoder(0, 1);
		rightEncoder.setPIDSourceType(PIDSourceType.kDisplacement);
		rightEncoder.setSamplesToAverage(10);
		rightEncoder.setMaxPeriod(.5);

		pwmWidth = new Counter(6); // get time of pwm high in microseconds
		pwmWidth.setSemiPeriodMode(true);// set counter for measuring pulse high

		lidarPowerEnable = new DigitalOutput(7);// lidar power enable
		lidarMode = new DigitalOutput(8);// lidar mode

		lidarPowerEnable.set(true);// enable lidar
		lidarMode.set(false);// set continuous mode



		firstFeeder = new CANTalon(5);
		firstFeeder.setInverted(true);
		secondFeeder = new CANTalon(6);
		secondFeeder.setInverted(false);

		topShooter = new CANTalon(10);
		topShooter.setInverted(false);
		bottomShooter = new CANTalon(7);
		bottomShooter.setInverted(true);
		agitator = new CANTalon(8);

		topShooter.changeControlMode(TalonControlMode.Disabled);
		bottomShooter.changeControlMode(TalonControlMode.Disabled);

		firstFeeder.changeControlMode(TalonControlMode.Disabled);
		secondFeeder.changeControlMode(TalonControlMode.Disabled);
		agitator.changeControlMode(TalonControlMode.Disabled);

		topShooter.setFeedbackDevice(FeedbackDevice.QuadEncoder);
		topShooter.reverseSensor(true);
		topShooter.configEncoderCodesPerRev(100);//COMPETITION
//		topShooter.configEncoderCodesPerRev(1024);//PRACTICE
		//topShooter.setPID(0.6, 0, 0.35, 0.31, 100, 3, 0);
		topShooter.setVoltageRampRate(12);
		
		bottomShooter.setFeedbackDevice(FeedbackDevice.QuadEncoder);
		bottomShooter.configEncoderCodesPerRev(100);
		bottomShooter.setPID(0.19, 0.4, 0, 0.28, 100, 3, 0);
		bottomShooter.reverseSensor(true);
		bottomShooter.setVoltageRampRate(12);
		
		compressor = new Compressor(0);

		gearGrip = new DoubleSolenoid(3, 4);
		//gearGrip.set(DoubleSolenoid.Value.kForward);
		gearLift = new DoubleSolenoid(1, 6);
		gearLift.set(DoubleSolenoid.Value.kReverse);
		gearPush1 = new DoubleSolenoid(2, 5);
		gearPush1.set(DoubleSolenoid.Value.kReverse);
		driveShifter = new DoubleSolenoid(0, 7);
		driveShifter.set(DoubleSolenoid.Value.kReverse);

		
		tiltCamera = new DoubleSolenoid(2,5,4);//on second PCM
		tiltCamera.set(DoubleSolenoid.Value.kForward);//lower camera

		leftUltrasoundSensor = new AnalogInput(0);
		leftUltrasoundSensor.setAverageBits(10);
		rightUltrasoundSensor = new AnalogInput(1);
		rightUltrasoundSensor.setAverageBits(10);

		greenLedsOn = new Relay(0);
		greenLedsOn.setDirection(Direction.kBoth);
		greenLedsOn.set(Value.kOff);

		// spareRelay = new Relay(0);
		// spareRelay.setDirection(Direction.kReverse);
		// spareRelay.set(Value.kOff);
		climberTrigger = new DigitalInput(9);

	}
}
